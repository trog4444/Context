All union-types should have a s.Match method for interop-pattern-matching.
    -- for F#, a function named 'case' can be made that takes FSharpFuncs
^% unless single-case
^% if single-case is a function, provide a 'Make' function that accepts a System.Func

All Functors, Applicatives, and Monads should implement Linq functions
    -- Select, Join*, SelectManyx2, Where, etc
        * Join can act as map2 AND monadplus `join`

All record types should have 's.With' methods to simulate record-with syntax for interop


possible Foldable functions:
    /// <summary>The concatenation of all the elements of a container of sequences.</summary>
    /// <exception cref="System.ArgumentNullException">Thrown when the sequence is null.</exception>
    val inline concat: ta -> ^a seq

    /// <summary>Map a function over all the elements of a container and concatenate the resulting sequences.</summary>
    /// <exception cref="System.ArgumentNullException">Thrown when the sequence is null.</exception>
    val inline concatMap: f: (^a -> ^b seq) -> ta -> ^b seq