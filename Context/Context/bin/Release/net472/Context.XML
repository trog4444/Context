<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Context</name></assembly>
<members>
<member name="T:DListext.Extension.Builder.DList.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:DListext.Extension.Builder.DList.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:DListext.Extension.Builder.DList.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_PercentGreater``3(PTR.Context.Type.Cont{``0,``1},``2)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_MultiplyGreater``3(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_MinusLess``2(PTR.Context.Type.Cont{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0})">
<summary>
 The result of running a CPS computation with a given final continuation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_LessPercentBar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Cont{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_LessPercent``3(``0,PTR.Context.Type.Cont{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_LessMultiplyMultiplyGreater``3(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_LessMultiplyGreater``3(PTR.Context.Type.Cont{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Cont{``0,``1})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_LessMultiply``3(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_LessLessEquals``3(Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Cont{``0,``1},``2},PTR.Context.Type.Cont{``0,``1})">
<summary>
 Sequentially compose two co-effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_GreaterMinus``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Cont{``1,``0})">
<summary>
 The result of running a CPS computation with a given final continuation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_GreaterGreaterEquals``3(PTR.Context.Type.Cont{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Cont{``0,``2}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,``2}},PTR.Context.Type.Cont{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_EqualsGreaterGreater``3(PTR.Context.Type.Cont{``0,``1},Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Cont{``0,``1},``2})">
<summary>
 Sequentially compose two co-effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.op_BarPercentGreater``3(PTR.Context.Type.Cont{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont`2.Append``2(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont`2">
<summary>
 A CPS (&quot;continuation-passing style&quot;) computation that uses an intermediate
 value of type `T` within a CPS computation to produce a final result of type `R`.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_PercentGreater``2(PTR.Context.Type.DList{``0},``1)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_MultiplyGreater``2(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``1})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_MinusLess``1(Microsoft.FSharp.Collections.FSharpList{``0},PTR.Context.Type.DList{``0})">
<summary>
 Apply a dlist to a list to get the underlying list with an extension.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessPercentBar``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.DList{``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessPercent``2(``0,PTR.Context.Type.DList{``1})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessMultiplyMultiplyGreater``2(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessMultiplyGreater``2(PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},PTR.Context.Type.DList{``0})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessMultiply``2(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``1})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessBarGreater``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_LessBarBarGreater``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_GreaterMinus``1(PTR.Context.Type.DList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply a dlist to a list to get the underlying list with an extension.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_GreaterGreaterEquals``2(PTR.Context.Type.DList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``1}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``1}},PTR.Context.Type.DList{``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.op_BarPercentGreater``2(PTR.Context.Type.DList{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.Empty``1">
<summary>
 The identity element for the composition operator.
</summary>
</member>
<member name="M:PTR.Context.Type.DList`1.Append``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.DList`1">
<summary>
 A difference list is a function that, given a list, returns the original
 contents of the difference list prepended to the given list.

 This structure supports O(1) `append` and `snoc` operations, making this structure
 more performant when used in certain, `append-heavy`, contexts.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_PercentGreater``3(``0,PTR.Context.Type.Either{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_MultiplyGreater``3(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_MinusLess``2(``0,PTR.Context.Type.Either{``1,``0})">
<summary>
 Return the contents of a Right-value or a default value otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_LessPercentBar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Either{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_LessPercent``3(PTR.Context.Type.Either{``0,``1},``2)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_LessMultiplyMultiplyGreater``3(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_LessMultiplyGreater``3(PTR.Context.Type.Either{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Either{``0,``1})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_LessMultiply``3(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_GreaterMinus``2(PTR.Context.Type.Either{``0,``1},``1)">
<summary>
 Return the contents of a Right-value or a default value otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_GreaterGreaterEquals``3(PTR.Context.Type.Either{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Either{``0,``2}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Either{``1,``2}},PTR.Context.Type.Either{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.op_BarPercentGreater``3(PTR.Context.Type.Either{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either`2.Append``2(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Either`2">
<summary>
 The Either type represents values with two possibilities:
 a value of type Either&lt;A, B&gt; is either `Left A` or `Right B`.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_PlusHatPlus``4(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``3})">
<summary>
 Split the input between the two argument arrows, retagging and merging their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_PercentGreater``2(``0,PTR.Context.Type.Lens{``1,``0})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_MultiplyHatMultiply``4(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``3})">
<summary>
 Split the input between the two argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_MultiplyGreater``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_MinusLess``2(``0,PTR.Context.Type.Lens{``0,``1})">
<summary>
 Run a `Lens` by applying a `getter` to the given value, then apply both to the `setter` to retrieve a final value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_LessPercentBar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_LessPercent``2(PTR.Context.Type.Lens{``0,``1},``1)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_LessMultiplyMultiplyGreater``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_LessMultiplyGreater``3(PTR.Context.Type.Lens{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Lens{``0,``1})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_LessMultiply``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_LessLessDot``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Compose two members of a category together.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_GreaterMinus``2(PTR.Context.Type.Lens{``0,``1},``0)">
<summary>
 Run a `Lens` by applying a `getter` to the given value, then apply both to the `setter` to retrieve a final value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_GreaterGreaterEquals``3(PTR.Context.Type.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Lens{``0,``2}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_GreaterGreaterDot``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``1,``2})">
<summary>
 Compose two members of a category together.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Lens{``1,``2}},PTR.Context.Type.Lens{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_BarPercentGreater``3(PTR.Context.Type.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_BarHatBar``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``1})">
<summary>
 Split the input between the two argument arrows and merge their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.op_AmpHatAmp``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``2})">
<summary>
 Fanout: send the input to both argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.Id``1">
<summary>
 Identity of the category.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens`2.Append``2(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens`2">
<summary>
 Acts like a property of an object that can be accessed through a `getter` and/or `setter`.
</summary>
</member>
<member name="T:PTR.Context.Type.Maybe`1">
 <summary>The Maybe type represents values which may or may not be exist.</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_PlusHatPlus``4(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``3})">
<summary>
 Split the input between the two argument arrows, retagging and merging their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_PercentGreater``3(``0,PTR.Context.Type.Reader{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_MultiplyHatMultiply``4(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``3})">
<summary>
 Split the input between the two argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_MultiplyGreater``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_MinusLess``2(``0,PTR.Context.Type.Reader{``0,``1})">
<summary>
 The result of running a computation with a given environment.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_LessPercentBar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_LessPercent``3(PTR.Context.Type.Reader{``0,``1},``2)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_LessMultiplyMultiplyGreater``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_LessMultiplyGreater``3(PTR.Context.Type.Reader{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Reader{``0,``1})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_LessMultiply``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_LessLessDot``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Compose two members of a category together.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_GreaterMinus``2(PTR.Context.Type.Reader{``0,``1},``0)">
<summary>
 The result of running a computation with a given environment.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_GreaterGreaterEquals``3(PTR.Context.Type.Reader{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Reader{``0,``2}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_GreaterGreaterDot``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``1,``2})">
<summary>
 Compose two members of a category together.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,``2}},PTR.Context.Type.Reader{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_BarPercentGreater``3(PTR.Context.Type.Reader{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_BarHatBar``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``1})">
<summary>
 Split the input between the two argument arrows and merge their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.op_AmpHatAmp``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``2})">
<summary>
 Fanout: send the input to both argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.Id``1">
<summary>
 Identity of the category.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader`2.Append``2(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader`2">
<summary>
 Computations which read values from a shared environment.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_PercentGreater``6(``0,PTR.Context.Type.RWS{``1,``2,``3,``4,``5})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_MultiplyGreater``7(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``2,``5,``3,``6})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_MinusLess``5(System.Tuple{``0,``1},PTR.Context.Type.RWS{``0,``1,``2,``3,``4})">
<summary>
 Unwrap an RWS computation as a function.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_LessPercentBar``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.RWS{``2,``3,``4,``5,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_LessPercent``6(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},``5)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_LessMultiplyMultiplyGreater``7(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``5,``1,``3,Microsoft.FSharp.Core.FSharpFunc{``4,``6}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_LessMultiplyGreater``7(PTR.Context.Type.RWS{``0,``1,``2,``3,Microsoft.FSharp.Core.FSharpFunc{``4,``5}},PTR.Context.Type.RWS{``0,``2,``6,``3,``4})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_LessMultiply``7(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``5,``1,``3,``6})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_GreaterMinus``5(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},System.Tuple{``0,``1})">
<summary>
 Unwrap an RWS computation as a function.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_GreaterGreaterEquals``7(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,PTR.Context.Type.RWS{``0,``2,``5,``3,``6}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_EqualsLessLess``7(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.RWS{``1,``2,``3,``4,``5}},PTR.Context.Type.RWS{``1,``6,``2,``4,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.op_BarPercentGreater``6(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},Microsoft.FSharp.Core.FSharpFunc{``4,``5})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS`5.Append``6(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``2,``5,``3,``4})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS`5">
<summary>
 A computation that, when given an input environment and an initial state,
 returns a modified state, a &apos;log&apos;, and an output.
</summary>
</member>
<member name="T:PTR.Context.Type.RWSResult`3">
<summary>
 Result of a `RWS` computation.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_PercentGreater``4(``0,PTR.Context.Type.State{``1,``2,``3})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_MultiplyGreater``5(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``1,``3,``4})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_MinusLess``3(``0,PTR.Context.Type.State{``0,``1,``2})">
<summary>
 The result of running a computation with a given environment.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_LessPercentBar``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.State{``2,``3,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_LessPercent``4(PTR.Context.Type.State{``0,``1,``2},``3)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_LessMultiplyMultiplyGreater``5(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``3,``0,Microsoft.FSharp.Core.FSharpFunc{``2,``4}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_LessMultiplyGreater``5(PTR.Context.Type.State{``0,``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}},PTR.Context.Type.State{``1,``4,``2})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_LessMultiply``5(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``3,``0,``4})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_GreaterMinus``3(PTR.Context.Type.State{``0,``1,``2},``0)">
<summary>
 The result of running a computation with a given environment.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_GreaterGreaterEquals``5(PTR.Context.Type.State{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``2,PTR.Context.Type.State{``1,``3,``4}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_EqualsLessLess``5(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.State{``1,``2,``3}},PTR.Context.Type.State{``4,``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.op_BarPercentGreater``4(PTR.Context.Type.State{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State`3.Append``4(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``1,``3,``2})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.State`3">
<summary>
 Stateful computations, i.e. computations that consume an initial state and
 return a value along with a new state.
</summary>
</member>
<member name="T:PTR.Context.Type.StateValue`2">
<summary>
 Result of a `State` computation.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_PercentGreater``3(``0,PTR.Context.Type.Writer{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_MultiplyGreater``3(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_MinusLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Writer{``0,``1})">
<summary>
 Unwrap a Writer computation as a (log, value) pair, with the logger having been run.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_LessPercentBar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Writer{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_LessPercent``3(PTR.Context.Type.Writer{``0,``1},``2)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_LessMultiplyMultiplyGreater``3(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_LessMultiplyGreater``3(PTR.Context.Type.Writer{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Writer{``0,``1})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_LessMultiply``3(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_LessLessEquals``3(Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},``2},PTR.Context.Type.Writer{``0,``1})">
<summary>
 Sequentially compose two co-effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_GreaterMinus``3(PTR.Context.Type.Writer{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Unwrap a Writer computation as a (log, value) pair, with the logger having been run.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_GreaterGreaterEquals``3(PTR.Context.Type.Writer{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Writer{``0,``2}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Writer{``1,``2}},PTR.Context.Type.Writer{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_EqualsGreaterGreater``3(PTR.Context.Type.Writer{``0,``1},Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},``2})">
<summary>
 Sequentially compose two co-effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.op_BarPercentGreater``3(PTR.Context.Type.Writer{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer`2.Append``2(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer`2">
<summary>
 Type that holds both a `log` and `value`.
</summary>
</member>
<member name="P:PTR.Context.Type.Cont.cont">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.cacheCont``2(PTR.Context.Type.Cont{``0,``1})">
<summary>
 Caches the result(s) of a `Cont` computation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.tryCC``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1}},``0)">
<summary>
 Attempt to apply `fOk` on an input and return a continuation. If the function fails,
 return a continuation with the result of applying `fErr` to the input and exception.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.getCC``3(``0)">
<summary>
 Allows looping with a given continuation function and input.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.callCC``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,``2}},PTR.Context.Type.Cont{``1,``0}})">
<summary>
 Call with current continuation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.reset``2(PTR.Context.Type.Cont{``0,``0})">
<summary>
 reset &apos;m&apos; delimits the continuation of any shift inside &apos;m&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.shift``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Cont{``1,``1}})">
<summary>
 shift &apos;f&apos; captures the continuation up to the nearest enclosing &apos;reset&apos; and passes it to &apos;f&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.exit``2(``0)">
<summary>
 End the current continuation chain with a specific value.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.withCont``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1}},PTR.Context.Type.Cont{``1,``2})">
<summary>
 Apply a function to transform the continuation passed to a CPS computation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.mapCont``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},PTR.Context.Type.Cont{``0,``1})">
<summary>
 Apply a function to transform the result of a continuation-passing computation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.evalCont``1(PTR.Context.Type.Cont{``0,``0})">
<summary>
 The result of running a CPS computation with the identity as the final continuation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.runCont``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Cont{``1,``0})">
<summary>
 The result of running a CPS computation with a given final continuation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Semigroup.sappend``2(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Comonad.recW``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Cont{``0,``0},``0},Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Cont{``0,``0},``0}},PTR.Context.Type.Cont{``0,``0})">
<summary>
 Deconstructs a comonad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Comonad.duplicate``2(PTR.Context.Type.Cont{``0,``1})">
<summary>
 Takes a comonadic container and produces a container of containers.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Comonad.extend``3(Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Cont{``0,``1},``2},PTR.Context.Type.Cont{``0,``1})">
<summary>
 Sequentially compose two co-effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Comonad.extract``1(PTR.Context.Type.Cont{``0,``0})">
<summary>
 Retrieve a value out of a context.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose.Comonad">
<summary>
 Supplementary Comonad operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Functor.tee``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Cont{``2,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Functor.replace``3(``0,PTR.Context.Type.Cont{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Functor.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Cont{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.replicateA``2(System.Int32,PTR.Context.Type.Cont{``0,``1})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.zipWithA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Cont{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.forA``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.sequenceA``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Cont{``0,``1}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.when_``1(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Cont{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.andThen``3(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Cont{``4,``0},PTR.Context.Type.Cont{``4,``1},PTR.Context.Type.Cont{``4,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Cont{``3,``0},PTR.Context.Type.Cont{``3,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.ap``3(PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Applicative.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose.Monad.ContBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.foldlM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Cont{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.foldrM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Cont{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.recMp``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Cont{``0,``1},PTR.Context.Type.Cont{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Cont{``0,``1}}},``1)">
<summary>
 Build a monad through recursive (effectful) computations. Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.recM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations. Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.flatten``2(PTR.Context.Type.Cont{``0,PTR.Context.Type.Cont{``0,``1}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Cont{``1,``2}},PTR.Context.Type.Cont{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Cont.Compose.Monad.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont.Compose">
<summary>
 Compositional operations on `Cont` values.
</summary>
</member>
<member name="T:PTR.Context.Type.Cont">
<summary>
 Operations on `Cont` values.
</summary>
</member>
<member name="P:PTR.Context.Type.DList.dlist">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.cacheDList``1(PTR.Context.Type.DList{``0})">
<summary>
 Caches a dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.withDList``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0}},PTR.Context.Type.DList{``0})">
<summary>
 Apply a &apos;list function&apos; before applying the given dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.mapDList``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.DList{``0})">
<summary>
 Map a function across the elements of a dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,PTR.Context.Type.DList{``0})">
<summary>
 Right-associative fold over the elements of a dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,PTR.Context.Type.DList{``1})">
<summary>
 Left-associative fold over the elements of a dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.tryTail``1(PTR.Context.Type.DList{``0})">
<summary>
 If a dlist contains at least one element, return the tail, else return an empty dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.tryHead``1(PTR.Context.Type.DList{``0})">
<summary>
 If a dlist contains at least one element, return the first element, else return an empty dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.listElim``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.DList{``1},``0}},PTR.Context.Type.DList{``1})">
<summary>
 List elimination for dlists.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.replicate``1(System.Int32,``0)">
<summary>
 Create a dlist of the given number of elements. /O(n)/
</summary>
</member>
<member name="M:PTR.Context.Type.DList.concat``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.DList{``0}})">
 <summary>Concatenate dlists. /O(spine)/</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.append``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 Append two dlists. /O(1)/
</summary>
</member>
<member name="M:PTR.Context.Type.DList.snoc``1(``0,PTR.Context.Type.DList{``0})">
<summary>
 Append a single element to a dlist. /O(1)/
</summary>
</member>
<member name="M:PTR.Context.Type.DList.cons``1(``0,PTR.Context.Type.DList{``0})">
<summary>
 Prepend a single element to a dlist. /O(1)/
</summary>
</member>
<member name="M:PTR.Context.Type.DList.singleton``1(``0)">
<summary>
 Create a dlist with a single element.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.empty``1">
<summary>
 Create a dlist containing no elements.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.applyDList``1(Microsoft.FSharp.Collections.FSharpList{``0},PTR.Context.Type.DList{``0})">
<summary>
 Apply a dlist to a list to get the underlying list with an extension.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.toList``1(PTR.Context.Type.DList{``0})">
<summary>
 Convert a dlist to a list.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.fromList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Convert a list to a dlist.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.unDList``1(PTR.Context.Type.DList{``0})">
<summary>
 Return the list-producing function from a dList.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monoid.mconcat``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.DList{``0}})">
 <summary>Combine elements of a sequence using monoidal composition.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monoid.mtimes``1(System.Int32,PTR.Context.Type.DList{``0})">
<summary>
 Repeat a value &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monoid.mempty``1">
<summary>
 The identity element for the composition operator.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monoid.mappend``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Monoid">
<summary>
 Types with a binary, associative composition operation and an identity element.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Semigroup.sappend``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Functor.tee``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.DList{``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Functor.replace``2(``0,PTR.Context.Type.DList{``1})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Functor.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.DList{``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.replicateA``1(System.Int32,PTR.Context.Type.DList{``0})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.zipWithA``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.DList{``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.forA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.sequenceA``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.DList{``0}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.filterA``1(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.when_(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.DList{Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.andThen``2(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``1})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``1},PTR.Context.Type.DList{``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.ap``2(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.wrap``1(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.Alternative.asum``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.DList{``0}})">
 <summary>The sum of a collection of effects.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.Alternative.alt``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.DList{``0}},PTR.Context.Type.DList{``0})">
<summary>
 Create a new item if the previous was empty, else keep the original.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.Alternative.optional``1(PTR.Context.Type.DList{``0})">
<summary>
 Return one or none results on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.Alternative.orElse``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Applicative.Alternative.empty``1">
<summary>
 The identity of orElse.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Applicative.Alternative">
<summary>
 A monoid on applicative functors.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Monad.DListBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.foldlM``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.DList{``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.foldrM``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.DList{``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.recMp``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations. Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.recM``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations. Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.flatten``1(PTR.Context.Type.DList{PTR.Context.Type.DList{``0}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.DList{``1}},PTR.Context.Type.DList{``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first
 as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.wrap``1(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.relate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``1,``3},PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``1})">
<summary>
 Combine two monads using a &apos;SQL style&apos; inner join function.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.recover``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.DList{``0}},PTR.Context.Type.DList{``0})">
<summary>
 Create a new item if the previous was mzero, else keep the original.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.guard(System.Boolean)">
<summary>
 Conditional failure of effectful computations.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.mplus``1(PTR.Context.Type.DList{``0},PTR.Context.Type.DList{``0})">
<summary>
 A monoidal operation on monads, supporting choice and failure.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.mzero``1">
<summary>
 The identity of mplus.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mpartitionChoice``2(PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
<summary>
 Collects the values from Choice1Of2s on the left, and from Choice2Of2s on the right.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mchoice2``2(PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
<summary>
 Collects the values from Choice2Of2&apos;s, while discarding the rest.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mchoice1``2(PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
<summary>
 Collects the values from Choice1Of2&apos;s, while discarding the rest.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mchoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},PTR.Context.Type.DList{``0})">
<summary>
 Generalizes the &apos;Seq.choose&apos; function.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mconcatOption``1(PTR.Context.Type.DList{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Translate a form of &apos;Option.defaultWith&apos; to an arbitrary &apos;MonadPlus&apos; type.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mofOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Translate a form of Option.defaultWith to an arbitrary &apos;MonadPlus&apos; type.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mpartitionSeq``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.DList{``0})">
<summary>
 Generalizes the &apos;Seq.partition&apos; function.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mremove``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.DList{``0})">
<summary>
 Opposite of the &apos;mwhere&apos; function.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mwhere``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.DList{``0})">
<summary>
 Generalizes the &apos;Seq.where&apos; function.
</summary>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.mOfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the 'ofSeq' function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.DList.Compose.Monad.Plus.General.msum``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.DList{``0}})">
 <summary>Generalizes list concatenation to monads.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Monad.Plus.General">
<summary>
 Generalizations of functions on other types.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Monad.Plus">
<summary>
 Monads that also support choice and failure.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.DList.Compose">
<summary>
 Compositional operations on `DList` values.
</summary>
</member>
<member name="T:PTR.Context.Type.DList">
<summary>
 Operations on `DList` values.
</summary>
</member>
<member name="P:PTR.Context.Type.Either.either">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.hush``2(PTR.Context.Type.Either{``0,``1})">
<summary>
 Removes the Left-value type from an Either, carrying Right-value(s) into a Some; None otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.partition``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Either{``0,``1}})">
 <summary>Partitions a list of Either into two lists. All the Left elements are extracted, in order,
 to the first component of the output. Similarly the Right elements are extracted to the second component of the output.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.rights``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Either{``0,``1}})">
 <summary>Extracts from a sequence of Eithers all the Right elements in order.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.lefts``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Either{``0,``1}})">
 <summary>Extracts from a sequence of Eithers all the Left elements in order.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.fromRightWith``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Either{``1,``0})">
<summary>
 Return the contents of a Right-value or a default value otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.fromRight``2(``0,PTR.Context.Type.Either{``1,``0})">
<summary>
 Return the contents of a Right-value or a default value otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.fromLeftWith``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Either{``0,``1})">
<summary>
 Return the contents of a Left-value or a default value otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.fromLeft``2(``0,PTR.Context.Type.Either{``0,``1})">
<summary>
 Return the contents of a Left-value or a default value otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.ofEither``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},PTR.Context.Type.Either{``2,``0})">
<summary>
 Apply one of the given functions to the value held within an Either, depending
 on if the value is &apos;Left&apos; or &apos;Right.&apos;
</summary>
</member>
<member name="M:PTR.Context.Type.Either.isRight``2(PTR.Context.Type.Either{``0,``1})">
<summary>
 Return True if the given value is a Right-value, False otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.isLeft``2(PTR.Context.Type.Either{``0,``1})">
<summary>
 Return True if the given value is a Left-value, False otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Semigroup.sappend``2(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Bifunctor.mapSnd``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Either{``2,``0})">
<summary>
 Map covariantly over the second argument.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Bifunctor.mapFst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Either{``0,``2})">
<summary>
 Map covariantly over the first argument.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Bifunctor.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},PTR.Context.Type.Either{``0,``2})">
<summary>
 Map over both arguments at the same time.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose.Bifunctor">
<summary>
 A two paramater functor where both the first and second arguments are covariant.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Functor.tee``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Either{``2,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Functor.replace``3(``0,PTR.Context.Type.Either{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Functor.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Either{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.replicateA``2(System.Int32,PTR.Context.Type.Either{``0,``1})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.zipWithA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Either{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.forA``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Either{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.sequenceA``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Either{``0,``1}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Either{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.when_``1(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Either{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.andThen``3(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Either{``4,``0},PTR.Context.Type.Either{``4,``1},PTR.Context.Type.Either{``4,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Either{``3,``0},PTR.Context.Type.Either{``3,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.ap``3(PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Applicative.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose.Monad.EitherBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.foldlM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Either{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.foldrM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Either{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.recMp``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Either{``0,``1},PTR.Context.Type.Either{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Either{``0,``1}}},``1)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.recM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Either{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Either{``1,``2}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.flatten``2(PTR.Context.Type.Either{``0,PTR.Context.Type.Either{``0,``1}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Either{``1,``2}},PTR.Context.Type.Either{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Compose.Monad.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Compose">
<summary>
 Compositional operations on `Either` values.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Convert.toResult``2(PTR.Context.Type.Either{``0,``1})">
<summary>
 Convert an Either to a Result.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Convert.ofResult``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Convert a Result to an Either.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Convert.toChoice``2(PTR.Context.Type.Either{``0,``1})">
<summary>
 Convert an Either to a Choice (Of2).
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Convert.ofChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Convert a Choice (Of2) to an Either.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Convert.toSeq``2(PTR.Context.Type.Either{``0,``1})">
<summary>
 Returns a singleton sequence if thet value is a Right-value, an empty sequence otherwise.
</summary>
</member>
<member name="M:PTR.Context.Type.Either.Convert.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns a Right-value with the head of a non-empty sequence and
 returns a Left-value if the sequence is empty. The Left-value will
 say if the input was either null or empty.
</summary>
</member>
<member name="T:PTR.Context.Type.Either.Convert">
<summary>
 Convert between values of type `Either` and related types.
</summary>
</member>
<member name="T:PTR.Context.Type.Either">
<summary>
 Operations on `Either` values.
</summary>
</member>
<member name="P:PTR.Context.Type.Lens.lens">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.cacheLens``2(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Caches both the &apos;getter&apos; and &apos;setter&apos; functions inside a Lens.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.lensSnd``2">
<summary>
 Lens&apos; equivalent of the standard &apos;snd&apos; function on tuples.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.lensFst``2">
<summary>
 Lens&apos; equivalent of the standard &apos;fst&apos; function on tuples.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.modLens``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``1,PTR.Context.Type.Lens{``1,``0})">
<summary>
 Retrieve a value with a &apos;getter&apos;, apply a function to it,
 then apply a &apos;setter&apos; to the result and the initial value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.lensSet``2(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Retrieve the &quot;setter&quot; from a &apos;Lens&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.lensGet``2(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Retrieve the &quot;getter&quot; from a &apos;Lens&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.mapLens``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Map a function across the components of a `Lens`.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.runLens``2(``0,PTR.Context.Type.Lens{``0,``1})">
<summary>
 Run a `Lens` by applying a `getter` to the given value,
 then apply both to the `setter` to retrieve a final value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.newLens``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}})">
<summary>
 Create a &apos;Lens&apos; given an accessor function and a setter function.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.fanout``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``2})">
<summary>
 Fanout: send the input to both argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.split``4(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``3})">
<summary>
 Split the input between the two argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.arrSnd``3(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Send the second component of the input through the argument arrow,
 and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.arrFst``3(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Send the first component of the input through the argument arrow,
 and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.arr``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lift a function to an arrow.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.Choice.fanin``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``1})">
<summary>
 Split the input between the two argument arrows and merge their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.Choice.merge``4(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``3})">
<summary>
 Split the input between the two argument arrows, retagging
 and merging their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.Choice.feed2``3(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Feed marked inputs through the argument arrow, passing the
 rest through unchanged to the output. A mirror of &apos;feed1&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.Choice.feed1``3(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Feed marked inputs through the argument arrow, passing the
 rest through unchanged to the output. A mirror of &apos;feed2&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Arrow.Choice.Apply.app``2">
<summary>
 Arrow that allows application of arrow inputs to other inputs.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Arrow.Choice.Apply">
<summary>
 Arrows that allow application of arrow inputs to other inputs.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Arrow.Choice">
<summary>
 Choice, for arrows that support it. This class underlies the
 &apos;if&apos; and &apos;case&apos; constructs in arrow notation.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Arrow">
<summary>
 Arrows are a general, abstract view of computation. In particular, they allow
 notions of computation that may be independent of the input or may take multiple inputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Cat.compose``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Compose two members of a category together.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Cat.identity``1">
<summary>
 Identity element of a category.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Cat">
<summary>
 Category -- includes an identity element and an associative composition function.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Semigroup.sappend``2(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Profunctor.rmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Map the second argument covariantly.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Profunctor.dimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},PTR.Context.Type.Lens{``1,``2})">
<summary>
 Map over both arguments at the same time.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Profunctor.lmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Lens{``1,``2})">
<summary>
 Map the first argument contravariantly.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Profunctor">
<summary>
 A functor where the first argument is contravariant and the second argument is covariant.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Functor.tee``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Functor.replace``2(``0,PTR.Context.Type.Lens{``1,``0})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Functor.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Lens{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.replicateA``2(System.Int32,PTR.Context.Type.Lens{``0,``1})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.zipWithA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Lens{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.forA``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Lens{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.sequenceA``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Lens{``0,``1}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Lens{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.when_``1(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Lens{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.andThen``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Lens{``4,``0},PTR.Context.Type.Lens{``4,``1},PTR.Context.Type.Lens{``4,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Lens{``3,``0},PTR.Context.Type.Lens{``3,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.ap``3(PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Applicative.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Monad.LensBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.foldlM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Lens{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.foldrM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Lens{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.recMp``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Lens{``0,``1},PTR.Context.Type.Lens{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Lens{``0,``1}}},``1)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.recM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Lens{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Lens{``1,``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.flatten``2(PTR.Context.Type.Lens{``0,PTR.Context.Type.Lens{``0,``1}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Lens{``1,``2}},PTR.Context.Type.Lens{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first
 as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Compose.Monad.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Compose">
<summary>
 Compositional operations on `Lens` values.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.LensCollection.MapL.memberL``2(``0)">
<summary>
 &apos;GetL&apos; attempts to retrieve a value from a Map given a key.

 &apos;SetL&apos; attempts to add a value to a Map.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.LensCollection.MapL">
<summary>
 Functions between Lenses and Maps.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.LensCollection">
<summary>
 Functions between Lenses and collections.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.LensState.focus``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``0,``1}},PTR.Context.Type.Lens{``2,``0},``2)">
<summary>
 Convert a stateful function of one state-type to another state-type.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.LensState.putL``2(PTR.Context.Type.Lens{``0,``1},``0)">
<summary>
 Use a &apos;Lens&apos; as a stateful function.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.LensState.modifyL``2(PTR.Context.Type.Lens{``0,``1},``1,``0)">
<summary>
 &apos;Stateful&apos; version of setL -- when the &apos;state&apos; value is left out,
 the function takes the form of &apos;state -&gt; state * content&apos;, which
 can be put inside the &apos;State&apos; type for stateful computations, where it
 behaves like the &apos;modify&apos; function.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.LensState">
<summary>
 Stateful `Lens` functions.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Pattern.|LensSet|``2(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Active pattern that can be used to extract the &quot;setter&quot; within a &apos;Lens&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Pattern.|LensGet|``2(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Active pattern that can be used to extract the &quot;getter&quot; within a &apos;Lens&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Lens.Pattern.|Lens|``2(PTR.Context.Type.Lens{``0,``1})">
<summary>
 Active pattern that can be used to extract both the &quot;getter&quot; and &quot;setter&quot; within a &apos;Lens&apos;.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens.Pattern">
<summary>
 Active patterns on `Lens` values.
</summary>
</member>
<member name="T:PTR.Context.Type.Lens">
<summary>
 Operations on `Lens` values.
</summary>
</member>
<member name="P:PTR.Context.Type.Maybe.maybe">
 <summary>Creates a computation expression for the given type.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Note``2(``0,PTR.Context.Type.Maybe{``1})">
 <summary>'Adds' a value/parameter to a Maybe-value by converting Just-values into Choice1Of2's,
 otherwise puts a default 'note' value into a Choice2Of2.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.MapMaybes``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Version of Seq.map that can throw out elements. If the result of 'f' is a Just value, the result is included, otherwise it is excluded.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.CatMaybes``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Maybe{``0}})">
 <summary>The catMaybes function takes a sequence of Maybes and returns a list of all the Just values.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.FromMaybe``1(``0,PTR.Context.Type.Maybe{``0})">
 <summary>Return the contents of a Just-value or a default value otherwise.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.OfMaybe``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0},PTR.Context.Type.Maybe{``1})">
 <summary>Takes a default value, a function, and a Maybe value.
 If the Maybe value is Nothing, the function returns the default value.
 Otherwise, it applies the function to the value inside the Just and returns the result.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.IsNothing``1(PTR.Context.Type.Maybe{``0})">
 <summary>Return true if the given value is a Nothing-value, false otherwise.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.IsJust``1(PTR.Context.Type.Maybe{``0})">
 <summary>Return true if the given value is a Just-value, false otherwise.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monoid.MConcat``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Maybe{``0}})">
 <summary>Combine elements of a sequence using monoidal composition.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monoid.MTimes``1(System.Int32,PTR.Context.Type.Maybe{``0})">
 <summary>Repeat a value 'n' times.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monoid.MEmpty``1">
 <summary>The identity element for the composition operator.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monoid.MAppend``1(PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``0})">
 <summary>An associative composition operation.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Monoid">
 <summary>Types with a binary, associative composition operation and an identity element.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Semigroup.SAppend``1(PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``0})">
 <summary>An associative composition operation.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Semigroup">
 <summary>Types with a binary, associative composition operation.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Functor.Tee``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Maybe{``0})">
 <summary>Perform an operation, store its result, perform an action using both the input and output, and finally return the output.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Functor.Replace``2(``0,PTR.Context.Type.Maybe{``1})">
 <summary>Replace all locations in the input with the same value.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Functor.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Maybe{``0})">
 <summary>Lift a function onto effects.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Functor">
 <summary>Supplementary Functor operations on the given type.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.ReplicateA``1(System.Int32,PTR.Context.Type.Maybe{``0})">
 <summary>Performs the effect 'n' times.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.ZipWithA``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Maybe{``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.ForA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.SequenceA``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Maybe{``0}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.FilterA``1(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.When(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Maybe{Microsoft.FSharp.Core.Unit}})">
 <summary>Conditional execution of effectful expressions.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.AndThen``2(PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``1})">
 <summary>Sequentially compose two effects, discarding any value produced by the first.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``1},PTR.Context.Type.Maybe{``2})">
 <summary>Lift a ternary function on effects.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``1})">
 <summary>Lift a binary function on effects.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Ap``2(PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Sequential application on effects.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Wrap``1(``0)">
 <summary>Lift a value onto an effectful context.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Alternative.Alt``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Maybe{``0}},PTR.Context.Type.Maybe{``0})">
 <summary>Create a new item if the previous was empty, else keep the original.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Alternative.Optional``1(PTR.Context.Type.Maybe{``0})">
 <summary>Return one or none results on effects.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Alternative.ASum``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Maybe{``0}})">
 <summary>The sum of a collection of effects.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Alternative.OrElse``1(PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``0})">
 <summary>An associative binary operation on applicative functors.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Applicative.Alternative.Empty``1">
 <summary>The identity of orElse.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Applicative.Alternative">
 <summary>A monoid on applicative functors.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Applicative">
 <summary>Supplementary Applicative operations on the given type.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Monad.MaybeBuilder">
 <summary>Monadic computation builder specialised to the given monad.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.FoldlM``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Maybe{``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.FoldrM``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Maybe{``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.RecMp``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``0}}},``0)">
 <summary>Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an 'effect' applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.RecM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``1}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``1}}},``0)">
 <summary>Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic 'identity' function is used in each iteration where the continuation is applied.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Flatten``1(PTR.Context.Type.Maybe{PTR.Context.Type.Maybe{``0}})">
 <summary>Removes one layer of monadic context from a nested monad.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``1}},PTR.Context.Type.Maybe{``0})">
 <summary>Sequentially compose two effects, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Wrap``1(``0)">
 <summary>Lift a value onto an effectful context.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.relate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``1,``3},PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``1})">
 <summary>Combine two monads using a 'SQL style' inner join function.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.recover``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Maybe{``0}},PTR.Context.Type.Maybe{``0})">
 <summary>Create a new item if the previous was mzero, else keep the original.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.guard(System.Boolean)">
 <summary>Conditional blocking of effectful computations.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.mplus``1(PTR.Context.Type.Maybe{``0},PTR.Context.Type.Maybe{``0})">
 <summary>A monoidal operation on monads, supporting choice and failure.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.mzero``1">
 <summary>The identity of mplus.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MPartitionChoice``2(PTR.Context.Type.Maybe{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
 <summary>Collects the values from Choice1Of2s on the left, and from Choice2Of2s on the right.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MChoice2``2(PTR.Context.Type.Maybe{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
 <summary>Collects the values from Choice2Of2's, while discarding the rest.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MChoice1``2(PTR.Context.Type.Maybe{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
 <summary>Collects the values from Choice1Of2's, while discarding the rest.</summary>                    
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MChoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},PTR.Context.Type.Maybe{``0})">
 <summary>Generalizes the 'Seq.choose' function.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MConcatOption``1(PTR.Context.Type.Maybe{Microsoft.FSharp.Core.FSharpOption{``0}})">
 <summary>Translate a form of 'Option.defaultWith' to an arbitrary 'MonadPlus' type.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MOfOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Translate a form of Option.defaultWith to an arbitrary 'MonadPlus' type.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MPartition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Maybe{``0})">
 <summary>Generalizes the 'Seq.partition' function.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MRemove``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Maybe{``0})">
 <summary>Opposite of the 'mwhere' function.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MWhere``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Maybe{``0})">
 <summary>Generalizes the 'Seq.where' function.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MOfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the 'ofSeq' function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Maybe.Compose.Monad.Plus.General.MSum``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Maybe{``0}})">
 <summary>Generalizes list concatenation to monads.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Monad.Plus.General">
 <summary>Generalizations of functions on other types.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Monad.Plus">
 <summary>Monads that also support choice and failure.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose.Monad">
 <summary>Supplementary Monad operations on the given type.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Compose">
 <summary>Compositional operations on Maybe values.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Convert.OfNullable``1(System.Nullable{``0})">
 <summary>Create a Just-value if the given object has a value, Nothing otherwise.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Convert.OfObj``1(``0)">
 <summary>Create a Just-value if the given object is not null, Nothing otherwise.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Convert.ToOption``1(PTR.Context.Type.Maybe{``0})">
 <summary>Convert a Maybe-type to a .NET Option-type. Nothing => None and Just a => Some a.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Convert.OfOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <summary>Convert a .NET Option-type to a Maybe-type. None => Nothing and Some a => Just a.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Convert.ToSeq``1(PTR.Context.Type.Maybe{``0})">
 <summary>Returns a singleton sequence if thet value is a Just-value, an empty sequence otherwise.</summary>
</member>
<member name="M:PTR.Context.Type.Maybe.Convert.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Returns a Just-value with the head of a non-empty sequence and returns Nothing if the sequence is empty.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe.Convert">
 <summary>Conversions between Maybes and related types.</summary>
</member>
<member name="T:PTR.Context.Type.Maybe">
 <summary>Operations on Maybes.</summary>
</member>
<member name="P:PTR.Context.Type.Reader.reader">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Convert a 2-arity, curried function into a function on a 2-tuple.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2})">
<summary>
 Convert a function on a 2-tuple to a 2-arity, curried function.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.konst1``2">
<summary>
 &apos;const&apos; function -- returns the first argument given and ignores the rest.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.konst``2(``0)">
<summary>
 &apos;const&apos; function -- returns the first argument given and ignores the rest.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Flip a function then wrap it inside of a Reader.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.cacheReader``2(PTR.Context.Type.Reader{``0,``1})">
<summary>
 Store computed results to prevent recomputation on the same inputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.local``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},PTR.Context.Type.Reader{``0,``1})">
<summary>
 Executes a computation in a modified environment.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.ask``1">
<summary>
 Retrieves the current environment.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.withReader``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Reader{``1,``2})">
<summary>
 Execute a computation in a modified environment.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.mapReader``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Transform the value returned by a Reader.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.runReader``2(``0,PTR.Context.Type.Reader{``0,``1})">
<summary>
 Runs a Reader and extracts the final value from it.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.fanout``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``2})">
<summary>
 Fanout: send the input to both argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.split``4(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``3})">
<summary>
 Split the input between the two argument arrows and combine their output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.arrSnd``3(PTR.Context.Type.Reader{``0,``1})">
<summary>
 Send the second component of the input through the argument arrow,
 and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.arrFst``3(PTR.Context.Type.Reader{``0,``1})">
<summary>
 Send the first component of the input through the argument arrow,
 and copy the rest unchanged to the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.arr``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lift a function to an arrow.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.Apply.app``2">
<summary>
 Arrow that allows application of arrow inputs to other inputs.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Arrow.Apply">
<summary>
 Arrows that allow application of arrow inputs to other inputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.Choice.fanin``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``1})">
<summary>
 Split the input between the two argument arrows and merge their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.Choice.merge``4(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``3})">
<summary>
 Split the input between the two argument arrows, retagging
 and merging their outputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.Choice.feed2``3(PTR.Context.Type.Reader{``0,``1})">
<summary>
 Feed marked inputs through the argument arrow, passing the
 rest through unchanged to the output. A mirror of &apos;feed1&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Arrow.Choice.feed1``3(PTR.Context.Type.Reader{``0,``1})">
<summary>
 Feed marked inputs through the argument arrow, passing the
 rest through unchanged to the output. A mirror of &apos;feed2&apos;.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Arrow.Choice">
<summary>
 Choice, for arrows that support it. This class underlies the
 &apos;if&apos; and &apos;case&apos; constructs in arrow notation.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Arrow">
<summary>
 Arrows are a general, abstract view of computation. In particular, they allow
 notions of computation that may be independent of the input or may take multiple inputs.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Cat.compose``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Compose two members of a category together.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Cat.identity``1">
<summary>
 Identity element of a category.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Cat">
<summary>
 Category -- includes an identity element and an associative composition function.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Semigroup.sappend``2(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Adjoint.leftBind``5(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,System.Tuple{``2,``3}}},PTR.Context.Type.Reader{``4,System.Tuple{``1,``0}})">
<summary>
 Monadic &apos;bind&apos; from the right-ajoint over its left-adjoint.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Adjoint.rightAdjunct``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,``2}},``1,``0)">
<summary>
 Deconstruct a functor&apos;s Left-adjoint using itself.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Adjoint.leftAdjunct``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``1)">
<summary>
 Lift a function on a functor&apos;s Left-adjoint into itself.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Adjoint.counit``2(``0,PTR.Context.Type.Reader{``0,``1})">
<summary>
 Deconstruct a functor&apos;s Left-adjoint (containing that functor) into a value.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Adjoint.unit``2(``0)">
<summary>
 Construct a functor&apos;s Left-adjoint within itself.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Adjoint">
<summary>
 Adjunction to the given functor.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Profunctor.rmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Map the second argument covariantly.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Profunctor.lmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Reader{``1,``2})">
<summary>
 Map the first argument contravariantly.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Profunctor.dimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},PTR.Context.Type.Reader{``1,``2})">
<summary>
 Map over both arguments at the same time.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Profunctor">
<summary>
 A functor where the first argument is contravariant and the second argument is covariant.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Functor.tee``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Functor.replace``3(``0,PTR.Context.Type.Reader{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Functor.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Reader{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.replicateA``2(System.Int32,PTR.Context.Type.Reader{``0,``1})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.zipWithA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Reader{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right,
 then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.forA``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right
 then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.sequenceA``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Reader{``0,``1}})">
 <summary>Evaluate each effect in the sequence from left to right,
 and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.when_``1(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Reader{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.andThen``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Reader{``4,``0},PTR.Context.Type.Reader{``4,``1},PTR.Context.Type.Reader{``4,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Reader{``3,``0},PTR.Context.Type.Reader{``3,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.ap``3(PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Applicative.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Monad.ReaderBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.foldlM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Reader{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.foldrM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Reader{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.recMp``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Reader{``0,``1},PTR.Context.Type.Reader{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Reader{``0,``1}}},``1)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.recM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.flatten``2(PTR.Context.Type.Reader{``0,PTR.Context.Type.Reader{``0,``1}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Reader{``1,``2}},PTR.Context.Type.Reader{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first
 as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Reader.Compose.Monad.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader.Compose">
<summary>
 Compositional operations on `Reader` values.
</summary>
</member>
<member name="T:PTR.Context.Type.Reader">
<summary>
 Operations on `Reader` values.
</summary>
</member>
<member name="P:PTR.Context.Type.RWS.rws">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.cacheRWS``5(PTR.Context.Type.RWS{``0,``1,``2,``3,``4})">
<summary>
 Cache the results of a &apos;RWS&apos; computation.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.withRWS``7(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``3}}},PTR.Context.Type.RWS{``2,``3,``4,``5,``6})">
<summary>
 Executes action with an initial environment and state modified by applying &apos;f&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.mapRWS``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,PTR.Context.Type.RWSResult{``3,``4,``5}}}},PTR.Context.Type.RWS{``6,``7,``0,``1,``2})">
<summary>
 Map the return value, final state, and output of a computation using the given function.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.execRWS``5(``0,``1,PTR.Context.Type.RWS{``0,``1,``2,``3,``4})">
<summary>
 Evaluate a computation with the given initial state and environment,
 returning the final state and output, discarding the final value.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.evalRWS``5(``0,``1,PTR.Context.Type.RWS{``0,``1,``2,``3,``4})">
<summary>
 Evaluate a computation with the given initial state and environment,
 returning the final value and output, discarding the final state.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.runRWS``5(``0,``1,PTR.Context.Type.RWS{``0,``1,``2,``3,``4})">
<summary>
 Unwrap an &apos;RWS&apos; computation as a function.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Semigroup.sappend``6(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``2,``5,``3,``4})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Trifunctor.mapThr``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.RWS{``2,``3,``4,``5,``0})">
<summary>
 Map covariantly over the third argument.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Trifunctor.mapSnd``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.RWS{``2,``3,``4,``0,``5})">
<summary>
 Map covariantly over the second argument.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Trifunctor.mapFst``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.RWS{``2,``3,``0,``4,``5})">
<summary>
 Map covariantly over the first argument.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Trifunctor.bimap``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},PTR.Context.Type.RWS{``4,``5,``6,``0,``2})">
<summary>
 Map over both arguments at the same time.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Trifunctor.trimap``8(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``4,``5},PTR.Context.Type.RWS{``6,``7,``0,``2,``4})">
<summary>
 Map over all three arguments at the same time.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose.Trifunctor">
<summary>
 A three paramater functor where the first, second, and third arguments are covariant.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Functor.tee``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.RWS{``2,``3,``4,``5,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Functor.replace``6(``0,PTR.Context.Type.RWS{``1,``2,``3,``4,``5})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Functor.map``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.RWS{``2,``3,``4,``5,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.replicateA``4(System.Int32,PTR.Context.Type.RWS{``0,``1,``1,``2,``3})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.zipWithA``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.RWS{``2,``3,``3,``4,``5}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right,
 then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.forA``5(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.RWS{``1,``2,``2,``3,``4}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right
 then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.sequenceA``4(System.Collections.Generic.IEnumerable{PTR.Context.Type.RWS{``0,``1,``1,``2,``3}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.filterA``4(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.RWS{``1,``2,``2,``3,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.when_``3(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.RWS{``0,``1,``1,``2,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.andThen``7(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``5,``1,``3,``6})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.map3``10(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.RWS{``4,``5,``6,``7,``0},PTR.Context.Type.RWS{``4,``6,``8,``7,``1},PTR.Context.Type.RWS{``4,``8,``9,``7,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.map2``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.RWS{``3,``4,``5,``6,``0},PTR.Context.Type.RWS{``3,``5,``7,``6,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.ap``7(PTR.Context.Type.RWS{``0,``1,``2,``3,``4},PTR.Context.Type.RWS{``0,``5,``1,``3,Microsoft.FSharp.Core.FSharpFunc{``4,``6}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Applicative.wrap``4(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose.Monad.RWSBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.foldlM``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.RWS{``2,``3,``3,``4,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.foldrM``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.RWS{``2,``3,``3,``4,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.recMp``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.RWS{``0,``1,``1,``2,``3},PTR.Context.Type.RWS{``0,``1,``1,``2,``3}},Microsoft.FSharp.Core.FSharpFunc{``3,PTR.Context.Type.RWS{``0,``1,``1,``2,``3}}},``3)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.recM``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.RWS{``1,``2,``2,``3,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.RWS{``1,``2,``2,``3,``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.flatten``6(PTR.Context.Type.RWS{``0,``1,``2,``3,PTR.Context.Type.RWS{``0,``2,``4,``3,``5}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.bind``7(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.RWS{``1,``2,``3,``4,``5}},PTR.Context.Type.RWS{``1,``6,``2,``4,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first
 as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.RWS.Compose.Monad.wrap``4(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS.Compose">
<summary>
 Compositional operations on `RWS` values.
</summary>
</member>
<member name="T:PTR.Context.Type.RWS">
<summary>
 Operations on `RWS` values.
</summary>
</member>
<member name="P:PTR.Context.Type.State.state">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.State.cacheState``3(PTR.Context.Type.State{``0,``1,``2})">
<summary>
 Store computed results to prevent recomputation on the same inputs.
</summary>
</member>
<member name="M:PTR.Context.Type.State.modify``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Maps an old state to a new state inside a state computation.
</summary>
</member>
<member name="M:PTR.Context.Type.State.put``2(``0)">
<summary>
 Replace the state inside the computation.
</summary>
</member>
<member name="M:PTR.Context.Type.State.get``1">
<summary>
 Retrieves the current state.
</summary>
</member>
<member name="M:PTR.Context.Type.State.withState``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.State{``1,``2,``3})">
<summary>
 withState f m executes action m on a state modified by applying f.
</summary>
</member>
<member name="M:PTR.Context.Type.State.mapState``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``3}}},PTR.Context.Type.State{``4,``0,``1})">
<summary>
 Map both the return value and final state of a computation using the given function.
</summary>
</member>
<member name="M:PTR.Context.Type.State.execState``3(``0,PTR.Context.Type.State{``0,``1,``2})">
<summary>
 Execute a state computation with the given initial state and return the final state,
 discarding the final value.
</summary>
</member>
<member name="M:PTR.Context.Type.State.evalState``3(``0,PTR.Context.Type.State{``0,``1,``2})">
<summary>
 Evaluate a state computation with the given initial state and return the final value,
 discarding the final state.
</summary>
</member>
<member name="M:PTR.Context.Type.State.runState``3(``0,PTR.Context.Type.State{``0,``1,``2})">
<summary>
 Run a state computation with the given initial state and return the final state and value from it.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Semigroup.sappend``4(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``1,``3,``2})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Bifunctor.mapSnd``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.State{``2,``3,``0})">
<summary>
 Map covariantly over the second argument.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Bifunctor.mapFst``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.State{``2,``0,``3})">
<summary>
 Map covariantly over the first argument.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Bifunctor.bimap``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},PTR.Context.Type.State{``4,``0,``2})">
<summary>
 Map over both arguments at the same time.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose.Bifunctor">
<summary>
 A two paramater functor where both the first and second arguments are covariant.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Functor.tee``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.State{``2,``3,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Functor.replace``4(``0,PTR.Context.Type.State{``1,``2,``3})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Functor.map``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.State{``2,``3,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.replicateA``2(System.Int32,PTR.Context.Type.State{``0,``0,``1})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.zipWithA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.State{``2,``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.forA``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.State{``1,``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.sequenceA``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.State{``0,``0,``1}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.State{``1,``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.when_``1(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.State{``0,``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.andThen``5(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``3,``0,``4})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.map3``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.State{``4,``5,``0},PTR.Context.Type.State{``5,``6,``1},PTR.Context.Type.State{``6,``7,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.map2``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.State{``3,``4,``0},PTR.Context.Type.State{``4,``5,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.ap``5(PTR.Context.Type.State{``0,``1,``2},PTR.Context.Type.State{``3,``0,Microsoft.FSharp.Core.FSharpFunc{``2,``4}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Applicative.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose.Monad.StateBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.foldlM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.State{``2,``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">
 Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.foldrM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.State{``2,``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">
 Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.recMp``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.State{``0,``0,``1},PTR.Context.Type.State{``0,``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.State{``0,``0,``1}}},``1)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.recM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.State{``1,``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.State{``1,``1,``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.flatten``4(PTR.Context.Type.State{``0,``1,PTR.Context.Type.State{``1,``2,``3}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.bind``5(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.State{``1,``2,``3}},PTR.Context.Type.State{``4,``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first
 as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Compose.Monad.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.State.Compose">
<summary>
 Compositional operations on `State` values.
</summary>
</member>
<member name="M:PTR.Context.Type.State.Pattern.|SVPair|``2(PTR.Context.Type.StateValue{``0,``1})">
<summary>
 Returns the state and value of a Stateful computation result as a pair (tuple).
</summary>
</member>
<member name="T:PTR.Context.Type.State.Pattern">
<summary>
 Active patterns on `State` values.
</summary>
</member>
<member name="T:PTR.Context.Type.State">
<summary>
 Operations on `State` values.
</summary>
</member>
<member name="P:PTR.Context.Type.Writer.writer">
<summary>
 Creates a computation expression for the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.listens``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Writer{``0,``2})">
<summary>
 Adds the result of applying &apos;f&apos; to the logger and combines it with the original value.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.listen``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Takes a Writer and combines its value and logger into a new value pair,
 while maintaining the same logger.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.tell``1(``0)">
<summary>
 Create a Writer with just a logger.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.runWriter``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Writer{``0,``1})">
<summary>
 Unwrap a Writer as a (log, value) pair.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Semigroup.sappend``2(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,``1})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Semigroup">
<summary>
 Types with a binary, associative composition operation.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Comonad.recW``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},``1},Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},``1}},PTR.Context.Type.Writer{``0,``1})">
<summary>
 Deconstructs a comonad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Comonad.duplicate``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Takes a comonadic container and produces a container of containers.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Comonad.extend``3(Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},``2},PTR.Context.Type.Writer{``0,``1})">
<summary>
 Sequentially compose two co-effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Comonad.extract``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Retrieve a value out of a context.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Comonad">
<summary>
 Supplementary Comonad operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Adjoint.rightBind``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Writer{``2,``3}}},Microsoft.FSharp.Core.FSharpFunc{``4,PTR.Context.Type.Writer{``1,``0}},``4)">
<summary>
 Monadic &apos;bind&apos; from the right-ajoint over its left-adjoint.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Adjoint.rightAdjunct``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Writer{``1,``0})">
<summary>
 Deconstruct a functor&apos;s Left-adjoint using itself.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Adjoint.leftAdjunct``3(Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},``2},``1,``0)">
<summary>
 Lift a function on a functor&apos;s Left-adjoint into itself.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Adjoint.counit``2(PTR.Context.Type.Writer{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Deconstruct a functor&apos;s Left-adjoint (containing that functor) into a value.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Adjoint.unit``2(``0,``1)">
<summary>
 Construct a functor&apos;s adjoint within itself.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Adjoint">
<summary>
 Adjunction to the given functor.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Bifunctor.mapSnd``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Writer{``2,``0})">
<summary>
 Map covariantly over the second argument.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Bifunctor.mapFst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Writer{``0,``2})">
<summary>
 Map covariantly over the first argument.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Bifunctor.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},PTR.Context.Type.Writer{``0,``2})">
<summary>
 Map over both arguments at the same time.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Bifunctor">
<summary>
 A two paramater functor where both the first and second arguments are covariant.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Functor.tee``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Writer{``2,``0})">
<summary>
 Perform an operation, store its result, perform an action using both
 the input and output, and finally return the output.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Functor.replace``3(``0,PTR.Context.Type.Writer{``1,``2})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Functor.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Writer{``2,``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Functor">
<summary>
 Supplementary Functor operations on the given type.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.replicateA``2(System.Int32,PTR.Context.Type.Writer{``0,``1})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.zipWithA``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Writer{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right,
 then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.forA``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Writer{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.sequenceA``2(System.Collections.Generic.IEnumerable{PTR.Context.Type.Writer{``0,``1}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.filterA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Writer{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.when_``1(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Writer{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.andThen``3(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,``2})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Writer{``4,``0},PTR.Context.Type.Writer{``4,``1},PTR.Context.Type.Writer{``4,``2})">
<summary>
 Lift a ternary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Writer{``3,``0},PTR.Context.Type.Writer{``3,``1})">
<summary>
 Lift a binary function on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.ap``3(PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Applicative.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Applicative">
<summary>
 Supplementary Applicative operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Monad.WriterBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.foldlM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Writer{``2,``0}}},``0,System.Collections.Generic.IEnumerable{``1})">
 <summary>Monadic fold over a structure associating to the left.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.foldrM``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Writer{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
 <summary>Monadic fold over a structure associating to the right.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.recMp``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{PTR.Context.Type.Writer{``0,``1},PTR.Context.Type.Writer{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Writer{``0,``1}}},``1)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to an &apos;effect&apos; applied over the intermediate result.
 Any constructor can be used in each iteration, in the case of union-types.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.recM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Writer{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Writer{``1,``0}}},``0)">
<summary>
 Build a monad through recursive (effectful) computations.
 Computation proceeds through the use of a continuation function applied to the intermediate result.
 The default monadic &apos;identity&apos; function is used in each iteration where the continuation is applied.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.flatten``2(PTR.Context.Type.Writer{``0,PTR.Context.Type.Writer{``0,``1}})">
<summary>
 Removes one layer of monadic context from a nested monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Writer{``1,``2}},PTR.Context.Type.Writer{``1,``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first
 as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Compose.Monad.wrap``2(``0)">
<summary>
 Lift a value onto an effectful context.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose.Monad">
<summary>
 Supplementary Monad operations on the given type.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Compose">
<summary>
 Compositional operations on `Writer` values.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Convert.toPair1``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Convert a `Writer` to a pair.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Convert.toPair``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Convert a `Writer` to a pair.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Convert.ofPair``2(``0,``1)">
<summary>
 Convert a pair `Writer`.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Convert">
<summary>
 Convert between values of type `Writer` and related types.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Pattern.|WriterValue|``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Return the value from a &apos;Writer&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Pattern.|WriterLog|``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Return the log from a &apos;Writer&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Writer.Pattern.|Writer|``2(PTR.Context.Type.Writer{``0,``1})">
<summary>
 Return a &apos;Writer&apos;-value as a log/value pair.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer.Pattern">
<summary>
 Active patterns on `Writer` values.
</summary>
</member>
<member name="T:PTR.Context.Type.Writer">
<summary>
 Operations on `Writer` values.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.SearchTree`1">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream`1">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_PercentGreater``2(PTR.Context.Type.Incomplete.Stream_{``0},``1)">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_MultiplyGreater``2(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``1})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_MinusLess``2(System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0},PTR.Context.Type.Incomplete.Stream_{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_MinusLess``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessPercentBar``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessPercent``2(``0,PTR.Context.Type.Incomplete.Stream_{``1})">
<summary>
 Replace all locations in the input with the same value.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessMultiplyMultiplyGreater``2(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessMultiplyGreater``2(PTR.Context.Type.Incomplete.Stream_{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 Sequential application on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessMultiply``2(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``1})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessBarGreater``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_LessBarBarGreater``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_GreaterMinus``2(PTR.Context.Type.Incomplete.Stream_{``0},System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_GreaterMinus``1(PTR.Context.Type.Incomplete.Stream_{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_GreaterGreaterEquals``2(PTR.Context.Type.Incomplete.Stream_{``0},Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Incomplete.Stream_{``1}})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Incomplete.Stream_{``1}},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 Sequentially compose two effects, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.op_BarPercentGreater``2(PTR.Context.Type.Incomplete.Stream_{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lift a function onto effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.Empty``1">
<summary>
 The identity element for the composition operator.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_`1.Append``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 An associative composition operation.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_`1">

</member>
<member name="T:PTR.Context.Type.Incomplete.NonEmpty`1">
<summary>
 Represents a sequence that has at least one element.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.UnitList`1">
<summary>
 List constructor used in the `NonEmpty` sequence type.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.Store`2">
<summary>
 The &apos;Store&apos; holds a constant value along with a modifiable &apos;accessor&apos;
 function which maps the &apos;stored value&apos; to the &apos;focus&apos;.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},PTR.Context.Type.Incomplete.SearchTree{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,PTR.Context.Type.Incomplete.SearchTree{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.initDeep``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.initWide``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,PTR.Context.Type.Incomplete.SearchTree{``0}})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.unfoldf``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Incomplete.SearchTree{``1}},``0}}},``0)">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.toSeq``1(PTR.Context.Type.Incomplete.SearchTree{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.ofArray``1(``0[])">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.Compose.flatten``1(PTR.Context.Type.Incomplete.SearchTree{PTR.Context.Type.Incomplete.SearchTree{``0}})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.Compose.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Incomplete.SearchTree{``1}},PTR.Context.Type.Incomplete.SearchTree{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.Compose.ap``2(PTR.Context.Type.Incomplete.SearchTree{``0},PTR.Context.Type.Incomplete.SearchTree{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.Compose.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Incomplete.SearchTree{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.SearchTree.Compose.wrap``1(``0)">

</member>
<member name="T:PTR.Context.Type.Incomplete.SearchTree.Compose">

</member>
<member name="T:PTR.Context.Type.Incomplete.SearchTree">

</member>
<member name="P:PTR.Context.Type.Incomplete.Stream.stream">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.cacheStream``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.exit``1">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.withStream``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.mapStream``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.skip``1(System.Int32,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.takeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.take``1(System.Int32,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Maybe{``1}},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.append``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.snoc``1(``0,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.cons``1(``0,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.empty``1">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.ofArray``1(``0[])">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.toStream``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monoid.mappend``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monoid.mempty``1">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Monoid">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Semigroup.sappend``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Semigroup">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Applicative.Alternative.alt``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0}},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Create a new item if the previous was empty, else keep the original.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Applicative.Alternative.optional``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Return one or none results on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Applicative.Alternative.asum``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0}})">
 <summary>The sum of a collection of effects.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Applicative.Alternative.orElse``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Applicative.Alternative.empty``1">
<summary>
 The identity of orElse.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Applicative.Alternative">
<summary>
 A monoid on applicative functors.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Applicative">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Monad.StreamBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monad.Plus.relate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``1,``3},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monad.Plus.recover``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0}},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monad.Plus.guard(System.Boolean)">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monad.Plus.mplus``1(PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0},PTR.Context.Type.Cont{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream.Compose.Monad.Plus.mzero``1">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Monad.Plus">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose.Monad">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream.Compose">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream">

</member>
<member name="P:PTR.Context.Type.Incomplete.Stream_.stream">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.cacheStream``1(PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.exit``1">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.withStream``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Incomplete.Stream_{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.mapStream``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.skip``1(System.Int32,PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.takeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.take``1(System.Int32,PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,PTR.Context.Type.Incomplete.Stream_{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.append``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.snoc``1(``0,PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.cons``1(``0,PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.empty``1">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.ofArray``1(``0[])">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monoid.mappend``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monoid.mempty``1">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Monoid">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Semigroup.sappend``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Semigroup">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Functor.tee``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Functor.replace``2(``0,PTR.Context.Type.Incomplete.Stream_{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Functor.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Functor">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.replicateA``1(System.Int32,PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 Performs the effect &apos;n&apos; times.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.zipWithA``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,PTR.Context.Type.Incomplete.Stream_{``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>Produce an effect for each pair of elements in the sequences from left to right, then evaluate each effect and collect the results.
 If one sequence is longer, its extra elements are ignored.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.forA``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Incomplete.Stream_{``1}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Produce an effect for the elements in the sequence from left to right then evaluate each effect, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.sequenceA``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Incomplete.Stream_{``0}})">
 <summary>Evaluate each effect in the sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.filterA``1(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Incomplete.Stream_{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Generalizes the sequence-based filter function.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.when_(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Incomplete.Stream_{Microsoft.FSharp.Core.Unit}})">
<summary>
 Conditional execution of effectful expressions.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.andThen``2(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``1})">
<summary>
 Sequentially compose two effects, discarding any value produced by the first.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``1},PTR.Context.Type.Incomplete.Stream_{``2})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.ap``2(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.wrap``1(``0)">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.Alternative.alt``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Incomplete.Stream_{``0}},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 Create a new item if the previous was empty, else keep the original.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.Alternative.optional``1(PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 Return one or none results on effects.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.Alternative.asum``1(System.Collections.Generic.IEnumerable{PTR.Context.Type.Incomplete.Stream_{``0}})">
 <summary>The sum of a collection of effects.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.Alternative.orElse``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">
<summary>
 An associative binary operation on applicative functors.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.Alternative.empty``1">
<summary>
 The identity of orElse.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative.Alternative">
<summary>
 A monoid on applicative functors.
</summary>
</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Applicative">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.StreamBuilder">
<summary>
 Monadic computation builder specialised to the given monad.
</summary>
</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.flatten``1(PTR.Context.Type.Incomplete.Stream_{PTR.Context.Type.Incomplete.Stream_{``0}})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,PTR.Context.Type.Incomplete.Stream_{``1}},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.wrap``1(``0)">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.Plus.relate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{``1,``3},PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``1})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.Plus.recover``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,PTR.Context.Type.Incomplete.Stream_{``0}},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.Plus.guard(System.Boolean)">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.Plus.mplus``1(PTR.Context.Type.Incomplete.Stream_{``0},PTR.Context.Type.Incomplete.Stream_{``0})">

</member>
<member name="M:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.Plus.mzero``1">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Monad.Plus">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose.Monad">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_.Compose">

</member>
<member name="T:PTR.Context.Type.Incomplete.Stream_">

</member>
<member name="T:PTR.Context.Extension.Builder.Cont.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Cont.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Cont.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Either.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Either.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Either.Combine.LastRight">
<summary>
 Returns the last `Right`-value if at least one `Right` exists, else the first `Left`-value.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Either.Combine.FirstRight">
<summary>
 Returns the first `Right`-value if at least one `Right` exists, else the last `Left`-value.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Either.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Lens.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Lens.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Lens.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Reader.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Reader.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Reader.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.RWS.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.RWS.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.RWS.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.State.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.State.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.State.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Writer.Combine.AsList">
<summary>
 Multiple `returns` result in the entire workflow returning a list of results.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Writer.Combine.Append">
<summary>
 Multiple `returns` result in all of the results being `appended` together.
</summary>
</member>
<member name="T:PTR.Context.Extension.Builder.Writer.Combine">
<summary>
 Adds default implementations of the `Combine` method to the specified workflow builder.

 NOTE: Only &apos;ONE&apos; `Combine` module should be opened at a time in any scope.
</summary>
</member>
</members>
</doc>
