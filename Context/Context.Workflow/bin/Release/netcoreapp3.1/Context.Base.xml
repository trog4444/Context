<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Context.Base</name></assembly>
<members>
<member name="M:Rogz.Context.Base.Cont`2.Of(System.Func{System.Func{`1,`0},`0})">
 <summary>Create a new context using 'System.Func' objects for .NET interop.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont`2.Invoke(System.Func{`1,`0})">
 <summary>The result of running a CPS computation with a given final continuation.</summary>
</member>
<member name="T:Rogz.Context.Base.Cont`2">
 <summary>The Continuation type represents computations in continuation-passing style (CPS).
 In CPS, a function's result is not returned immediately, but instead is passed to another function, received as a parameter (continuation).
 Computations are built up from sequences of nested continuations, terminated by a final continuation which produces the final result.</summary>
</member>
<member name="M:Rogz.Context.Base.Either`2.op_Addition``2(Rogz.Context.Base.Either{``0,``1},Rogz.Context.Base.Either{``0,``1})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="M:Rogz.Context.Base.Either`2.TryRight(Microsoft.FSharp.Core.byref{`1,Microsoft.FSharp.Core.ByRefKinds.Out})">
 <summary>Tries to return the specified value. A return value indicates whether the operation succeeded.</summary>
</member>
<member name="M:Rogz.Context.Base.Either`2.TryLeft(Microsoft.FSharp.Core.byref{`0,Microsoft.FSharp.Core.ByRefKinds.Out})">
 <summary>Tries to return the specified value. A return value indicates whether the operation succeeded.</summary>
</member>
<member name="M:Rogz.Context.Base.Either`2.Match(System.Action{`0},System.Action{`1})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
</member>
<member name="M:Rogz.Context.Base.Either`2.Match``1(System.Func{`0,``0},System.Func{`1,``0})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe`1.op_Addition``1(Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{``0})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="P:Rogz.Context.Base.Maybe`1.Zero">
 <summary>The identity element of the Monoidal 'append' operation.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe`1.TryJust(Microsoft.FSharp.Core.byref{`0,Microsoft.FSharp.Core.ByRefKinds.Out})">
 <summary>Tries to return the specified value. A return value indicates whether the operation succeeded.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe`1.Match(System.Action,System.Action{`0})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe`1.Match``1(System.Func{``0},System.Func{`0,``0})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
</member>
<member name="T:Rogz.Context.Base.Maybe`1">
 <summary>The type of optional value. 'Just a' represents a value 'a',
 while 'Nothing' represents cases such as when a value does not exist or can't be reached.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader`2.op_Addition``2(Rogz.Context.Base.Reader{``0,``1},Rogz.Context.Base.Reader{``0,``1})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader`2.Of(System.Func{`0,`1})">
 <summary>Create a new context using 'System.Func' objects for .NET interop.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader`2.Invoke(`0)">
 <summary>The result of running the given computation.</summary>
</member>
<member name="T:Rogz.Context.Base.Reader`2">
 <summary>Represents one or more computations that share an input 'environment'.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS`4.Invoke(`0,`1)">
 <summary>Execute the given computation.</summary>
</member>
<member name="T:Rogz.Context.Base.RWS`4">
 <summary>A computation taking an environment and an initial state
 which produceds a new state, a 'log', and a value.</summary>
</member>
<member name="T:Rogz.Context.Base.RWSResult`3">
 <summary>The result of an 'RWS' computation.</summary>
</member>
<member name="M:Rogz.Context.Base.State`2.op_Addition``2(Rogz.Context.Base.State{``0,``1},Rogz.Context.Base.State{``0,``1})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="M:Rogz.Context.Base.State`2.Of``2(System.Func{``0,System.ValueTuple{``0,``1}})">
 <summary>Create a new context using 'System.Func' objects for .NET interop.</summary>
</member>
<member name="M:Rogz.Context.Base.State`2.Invoke(`0)">
 <summary>Execute the given stateful computation.</summary>
</member>
<member name="T:Rogz.Context.Base.State`2">
 <summary>Represents a 'stateful'-computation, threading each new state as an argument in a resultant state-value pair.</summary>
</member>
<member name="P:Rogz.Context.Base.Tagged`2.Value">
 <summary>Return the underlying value.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged`2.Match(System.Action{`1})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate action based on the case.</summary>
 <exception cref="ArgumentNullException">Thrown when the action attempting to be called is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Tagged`2.Match``1(System.Func{`1,``0})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
 <exception cref="ArgumentNullException">Thrown when the function attempting to be called is null.</exception>
</member>
<member name="T:Rogz.Context.Base.Tagged`2">
 <summary>Represents a type that is 'tagged' with extra type information,
 which is not used in actual calculations.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer`2.op_Addition``2(Rogz.Context.Base.Writer{``0,``1},Rogz.Context.Base.Writer{``0,``1})">
 <summary>Acts as the semigroup, binary 'append' operator.</summary>
</member>
<member name="T:Rogz.Context.Base.Writer`2">
 <summary>Adds an 'accumulation' value to another value,
 threading the accumulation through sequential computations.</summary>
</member>
<member name="P:Rogz.Context.Base.Cont.cont">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.fixM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Cont{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Cont{``1,``0},Rogz.Context.Base.Cont{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Cont{``1,``2}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.Cont{``1,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.flatten``2(Rogz.Context.Base.Cont{``0,Rogz.Context.Base.Cont{``0,``1}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Cont{``1,``2}},Rogz.Context.Base.Cont{``1,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Cont{``1,``2}},``3)">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Cont.sequence``3(``0)">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Cont.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Cont{``3,``0},Rogz.Context.Base.Cont{``3,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.ap``3(Rogz.Context.Base.Cont{``0,``1},Rogz.Context.Base.Cont{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.Unit``2(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Cont{``2,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.getCC``3(``0)">
 <summary>Allows looping with a given continuation function and input.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.callCC``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Cont{``1,``2}},Rogz.Context.Base.Cont{``1,``0}})">
 <summary>'callCC' (call-with-current-continuation) calls a function with the current continuation as its argument.
 This provides an escape continuation mechanism for use with Continuations.
 Escape continuations allow controlled escape from the current computation to return a value immediately.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.reset``2(Rogz.Context.Base.Cont{``0,``0})">
 <summary>'reset cont' delimits the continuation of any 'shift' inside 'cont'.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.shift``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Cont{``1,``1}})">
 <summary>'shift f' captures the continuation up to the nearest enclosing 'reset' and passes it to 'f'.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.withCont``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1}},Rogz.Context.Base.Cont{``1,``2})">
 <summary>Apply a function to transform the continuation passed to a CPS computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.mapCont``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},Rogz.Context.Base.Cont{``0,``1})">
 <summary>Apply a function to transform the result of a continuation-passing computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.evalCont``1(Rogz.Context.Base.Cont{``0,``0})">
 <summary>The result of running a CPS computation with the identity function as the final continuation.</summary>
</member>
<member name="M:Rogz.Context.Base.Cont.runCont``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Cont{``1,``0})">
 <summary>The result of running a CPS computation with a given final continuation.</summary>
</member>
<member name="T:Rogz.Context.Base.Cont.Workflow.ContBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.Cont.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.Cont">
 <summary>Operations on Continuations.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.bimapFoldBack``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``4,``1}}},``1,Rogz.Context.Base.Either{``0,``3})">
 <summary>Combines the functionality of map and foldBack, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.bimapFold``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``3,System.ValueTuple{``4,``0}}},``0,Rogz.Context.Base.Either{``1,``3})">
 <summary>Combines the functionality of map and fold, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.bifoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,Rogz.Context.Base.Either{``0,``2})">
 <summary>Applies a function to all element(s) of two possible sources, threading an accumulator argument through the computation(s).</summary>
</member>
<member name="M:Rogz.Context.Base.Either.bifold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``0}},``0,Rogz.Context.Base.Either{``1,``2})">
 <summary>Applies a function to all element(s) of two possible sources, threading an accumulator argument through the computation(s).</summary>
</member>
<member name="M:Rogz.Context.Base.Either.mapFoldBack``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},``1,Rogz.Context.Base.Either{``3,``0})">
 <summary>Combines the functionality of map and foldBack, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.mapFold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``0}}},``0,Rogz.Context.Base.Either{``3,``1})">
 <summary>Combines the functionality of map and fold, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,Rogz.Context.Base.Either{``2,``0})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Rogz.Context.Base.Either{``2,``1})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.append``2(Rogz.Context.Base.Either{``0,``1},Rogz.Context.Base.Either{``0,``1})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="P:Rogz.Context.Base.Either.either">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.fixM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Either{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Either{``1,``0},Rogz.Context.Base.Either{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Either{``1,``2}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.Either{``1,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.flatten``2(Rogz.Context.Base.Either{``0,Rogz.Context.Base.Either{``0,``1}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Either{``1,``2}},Rogz.Context.Base.Either{``1,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.orElseWith``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Rogz.Context.Base.Either{``0,``1}},Rogz.Context.Base.Either{``0,``1})">
 <summary>An associative operation representing a decision between two structures.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.orElse``2(Rogz.Context.Base.Either{``0,``1},Rogz.Context.Base.Either{``0,``1})">
 <summary>An associative operation representing a decision between two structures.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Either{``1,``2}},``3)">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Either.sequence``3(``0)">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Either.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Either{``3,``0},Rogz.Context.Base.Either{``3,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.ap``3(Rogz.Context.Base.Either{``0,``1},Rogz.Context.Base.Either{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.Unit``2(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.mapFirst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Either{``0,``2})">
 <summary>Map over the first value, leaving the second value as-is.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Rogz.Context.Base.Either{``0,``2})">
 <summary>Map over both arguments covariantly.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Either{``2,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.partition``2(System.Collections.Generic.IEnumerable{Rogz.Context.Base.Either{``0,``1}})">
 <summary>Partitions a sequence of Eithers into a 'Left'-sequence and a 'Right'-sequence.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Either.fromRight``2(``0,Rogz.Context.Base.Either{``1,``0})">
 <summary>Return the contents of a Right-value or a default value otherwise.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.fromLeft``2(``0,Rogz.Context.Base.Either{``0,``1})">
 <summary>Return the contents of a Left-value or a default value otherwise.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.isRight``2(Rogz.Context.Base.Either{``0,``1})">
 <summary>Returns true if the value is a 'Right'; false otherwise.</summary>
</member>
<member name="M:Rogz.Context.Base.Either.isLeft``2(Rogz.Context.Base.Either{``0,``1})">
 <summary>Returns true if the value is a 'Left'; false otherwise.</summary>    
</member>
<member name="M:Rogz.Context.Base.Either.rights``2(System.Collections.Generic.IEnumerable{Rogz.Context.Base.Either{``0,``1}})">
 <summary>Returns all values held within 'Right'-values, and removes all others.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Either.lefts``2(System.Collections.Generic.IEnumerable{Rogz.Context.Base.Either{``0,``1}})">
 <summary>Returns all values held within 'Left'-values, and removes all others.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Either.caseof``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Rogz.Context.Base.Either{``0,``2})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
</member>
<member name="T:Rogz.Context.Base.Either.Workflow.EitherBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.Either.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.Either">
 <summary>Operations on Eithers.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.mapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},``1,Rogz.Context.Base.Maybe{``0})">
 <summary>Combines the functionality of map and foldBack, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.mapFold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``0}}},``0,Rogz.Context.Base.Maybe{``1})">
 <summary>Combines the functionality of map and fold, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,Rogz.Context.Base.Maybe{``0})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Rogz.Context.Base.Maybe{``1})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.sum``2(``0)">
 <summary>Generalizes the 'concat' operation on sequences to monoids.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Maybe.zero``1">
 <summary>The identity element of the Monoidal 'append' operation.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.append``1(Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{``0})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.join``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{``1})">
 <summary>Acts similar to a SQL 'inner join', combining elements of each given monad when the elements satisfy a predicate.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Rogz.Context.Base.Maybe{``0})">
 <summary>Generalizes the sequence-based 'filter' function.</summary>
</member>
<member name="P:Rogz.Context.Base.Maybe.maybe">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.fixM``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Maybe{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Maybe{``1}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.Maybe{``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.flatten``1(Rogz.Context.Base.Maybe{Rogz.Context.Base.Maybe{``0}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Maybe{``1}},Rogz.Context.Base.Maybe{``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.concat``2(``0)">
 <summary>Generalizes the sequence-based 'concat' function.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Maybe.guard(System.Boolean)">
 <summary>If the condition is true, do 'nothing', otherwise 'choose/fail' in the context of the monad.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.orElseWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Rogz.Context.Base.Maybe{``0}},Rogz.Context.Base.Maybe{``0})">
 <summary>An associative operation representing a decision between two structures.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.orElse``1(Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{``0})">
 <summary>An associative operation representing a decision between two structures.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.empty``1">
 <summary>The identity element of 'Alternative' operation(s).</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.traverse``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Maybe{``1}},``2)">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Maybe.sequence``2(``0)">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Maybe.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.ap``2(Rogz.Context.Base.Maybe{``0},Rogz.Context.Base.Maybe{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.Unit``1(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Maybe{``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.ofNullable``1(System.Nullable{``0})">
 <summary>Convert a Nullable to a Maybe.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.ofObj``1(``0)">
 <summary>Returns Nothing if the given object is null, otherwise returns the object wrapped in a 'Just'.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.mapMaybes``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Maybe{``1}},``2)">
 <summary>Map a Maybe-producing function across a sequence and return only the Just-values.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Maybe.toSeq``1(Rogz.Context.Base.Maybe{``0})">
 <summary>Returns an empty list when given Nothing or a singleton list when given Just.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.ofSeq``2(``0)">
 <summary>Returns 'Nothing' on an empty sequence or 'Just' the head of the sequence.</summary>
 <exception cref="ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Maybe.fromMaybe``1(``0,Rogz.Context.Base.Maybe{``0})">
 <summary>The fromMaybe function takes a default value and and Maybe value. If the Maybe is Nothing, it returns the default values; otherwise, it returns the value contained in the Maybe.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.isNothing``1(Rogz.Context.Base.Maybe{``0})">
 <summary>Returns true if the value is a 'Nothing'; false otherwise.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.isJust``1(Rogz.Context.Base.Maybe{``0})">
 <summary>Returns true if the value is a 'Just'; false otherwise.</summary>
</member>
<member name="M:Rogz.Context.Base.Maybe.caseof``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Rogz.Context.Base.Maybe{``1})">
 <summary>Acts as a pattern-match on a union-type, calling the appropriate function based on the case.</summary>
</member>
<member name="T:Rogz.Context.Base.Maybe.Workflow.MaybeBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.Maybe.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.Maybe">
 <summary>Operations on Maybe</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.append``2(Rogz.Context.Base.Reader{``0,``1},Rogz.Context.Base.Reader{``0,``1})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="P:Rogz.Context.Base.Reader.reader">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.fixM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Reader{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Reader{``1,``0},Rogz.Context.Base.Reader{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Reader{``1,``2}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.Reader{``1,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.flatten``2(Rogz.Context.Base.Reader{``0,Rogz.Context.Base.Reader{``0,``1}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Reader{``1,``2}},Rogz.Context.Base.Reader{``1,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Reader{``1,``2}},``3)">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Reader.sequence``3(``0)">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Reader.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Reader{``3,``0},Rogz.Context.Base.Reader{``3,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.ap``3(Rogz.Context.Base.Reader{``0,``1},Rogz.Context.Base.Reader{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.Unit``2(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.mapl``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Reader{``1,``2})">
 <summary>Map the first (i.e. 'left') argument contravariantly.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.dimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Rogz.Context.Base.Reader{``1,``2})">
 <summary>Map over both arguments at the same time, the first (i.e. 'left') contravariantly and the second (i.e. 'right') covariantly.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Reader{``2,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.runReader``2(``0,Rogz.Context.Base.Reader{``0,``1})">
 <summary>Execute the given function with the supplied environment.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.local``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},Rogz.Context.Base.Reader{``0,``1})">
 <summary>Executes a computation in a modified environment.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.asks``2(System.Func{``0,``1})">
 <summary>The selector function to apply to the environment.</summary>
</member>
<member name="M:Rogz.Context.Base.Reader.ask``1">
 <summary>Retreive the current environment.</summary>
</member>
<member name="T:Rogz.Context.Base.Reader.Workflow.ReaderBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.Reader.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.Reader">
 <summary>Operations on Readers.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.append``4(Rogz.Context.Base.RWS{``0,``1,``2,``3},Rogz.Context.Base.RWS{``0,``1,``2,``3})">
 <summary>Acts as the semigroup, binary 'append' operator.</summary>
</member>
<member name="P:Rogz.Context.Base.RWS.rws">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.fixM``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.RWS{``1,``2,``3,``4}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.RWS{``1,``2,``3,``0},Rogz.Context.Base.RWS{``1,``2,``3,``4}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.RWS{``1,``2,``3,``4}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.RWS{``1,``2,``3,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.flatten``4(Rogz.Context.Base.RWS{``0,``1,``2,Rogz.Context.Base.RWS{``0,``1,``2,``3}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.bind``5(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.RWS{``1,``2,``3,``4}},Rogz.Context.Base.RWS{``1,``2,``3,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.bimap2``8(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,``5}},Rogz.Context.Base.RWS{``6,``7,``0,``3},Rogz.Context.Base.RWS{``6,``7,``1,``4})">
 <summary>Lift two binary functions onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.biunit``4(``0,``1)">
 <summary>Lift two values into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.traverse``5(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.RWS{``1,``2,``3,``4}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.RWS.sequence``4(System.Collections.Generic.IEnumerable{Rogz.Context.Base.RWS{``0,``1,``2,``3}})">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.RWS.map2``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.RWS{``3,``4,``5,``0},Rogz.Context.Base.RWS{``3,``4,``5,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.ap``5(Rogz.Context.Base.RWS{``0,``1,``2,``3},Rogz.Context.Base.RWS{``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.unit``4(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.mapFirst``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.RWS{``2,``3,``0,``4})">
 <summary>Map over the first value, leaving the second value as-is.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.bimap``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Rogz.Context.Base.RWS{``4,``5,``0,``2})">
 <summary>Map over both arguments covariantly.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.map``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.RWS{``2,``3,``4,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.withRWS``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},Rogz.Context.Base.RWS{``2,``1,``3,``4})">
 <summary>Executes a computation on an environment and state modified by 'f'.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.mapRWS``6(Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.RWSResult{``0,``1,``2},Rogz.Context.Base.RWSResult{``0,``3,``4}},Rogz.Context.Base.RWS{``5,``0,``1,``2})">
 <summary>Map the return log, value, and final state of a computation using the given function.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.runRWS``4(``0,``1,Rogz.Context.Base.RWS{``0,``1,``2,``3})">
 <summary>Execute the given function with the supplied environment and initial state.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.gets``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Gets specific component of the state, using a projection function supplied.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.modify``3(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
 <summary>Maps an old state to a new state, discarding the old state.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.put``3(``0)">
 <summary>Ignore the current state and put a new state into a computation.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.get``3">
 <summary>Return the current state as a value.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.listens``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.RWS{``3,``4,``0,``1})">
 <summary>Applies a function to the accumulator then attaches the result to the output.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.listen``4(Rogz.Context.Base.RWS{``0,``1,``2,``3})">
 <summary>Attaches the accumulated value to the output.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.tell``3(``0)">
 <summary>Insert a 'record' into the accumulation.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.local``4(Microsoft.FSharp.Core.FSharpFunc{``0,``0},Rogz.Context.Base.RWS{``0,``1,``2,``3})">
 <summary>Executes a computation in a modified environment.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.asks``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Gets specific component of the environment, using a projection function supplied.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.ask``3">
 <summary>Retreive the current environment.</summary>
</member>
<member name="M:Rogz.Context.Base.RWS.fromFunc``4(System.Func{``0,``1,Rogz.Context.Base.RWSResult{``1,``2,``3}})">
 <summary>Create a RWS from the given function.</summary>
</member>
<member name="T:Rogz.Context.Base.RWS.Workflow.RWSBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.RWS.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.RWS">
 <summary>Operations on RWSs.</summary>
</member>
<member name="M:Rogz.Context.Base.State.append``2(Rogz.Context.Base.State{``0,``1},Rogz.Context.Base.State{``0,``1})">
 <summary>An associative binary operation on monoidal types.</summary>
</member>
<member name="P:Rogz.Context.Base.State.state">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.State.fixM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.State{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.State{``1,``0},Rogz.Context.Base.State{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.State{``1,``2}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.State{``1,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.State.flatten``2(Rogz.Context.Base.State{``0,Rogz.Context.Base.State{``0,``1}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.State.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.State{``1,``2}},Rogz.Context.Base.State{``1,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.State.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.State{``1,``2}},``3)">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.State.sequence``3(``0)">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.State.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.State{``3,``0},Rogz.Context.Base.State{``3,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.State.ap``3(Rogz.Context.Base.State{``0,``1},Rogz.Context.Base.State{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.State.Unit``2(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.State.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.State{``2,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.State.withState``2(Microsoft.FSharp.Core.FSharpFunc{``0,``0},Rogz.Context.Base.State{``0,``1})">
 <summary>Executes a stateful computation on a state modified by 'f'.</summary>
</member>
<member name="M:Rogz.Context.Base.State.mapState``3(Microsoft.FSharp.Core.FSharpFunc{System.ValueTuple{``0,``1},System.ValueTuple{``0,``2}},Rogz.Context.Base.State{``0,``1})">
 <summary>Map both the return value and final state of a computation using the given function.</summary>
</member>
<member name="M:Rogz.Context.Base.State.execState``2(``0,Rogz.Context.Base.State{``0,``1})">
 <summary>Evaluate a state computation with the given initial state and return the final state, discarding the final value.</summary>
</member>
<member name="M:Rogz.Context.Base.State.evalState``2(``0,Rogz.Context.Base.State{``0,``1})">
 <summary>Evaluate a state computation with the given initial state and return the final value, discarding the final state.</summary>
</member>
<member name="M:Rogz.Context.Base.State.runState``2(``0,Rogz.Context.Base.State{``0,``1})">
 <summary>Execute the given stateful computation.</summary>
</member>
<member name="M:Rogz.Context.Base.State.gets``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Gets specific component of the state, using a projection function supplied.</summary>
</member>
<member name="M:Rogz.Context.Base.State.modify``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
 <summary>Maps an old state to a new state, discarding the old state.</summary>
</member>
<member name="M:Rogz.Context.Base.State.stateful``2(System.Func{``0,System.ValueTuple{``0,``1}})">
 <summary>Embed a simple state action.</summary>
</member>
<member name="M:Rogz.Context.Base.State.put``1(``0)">
 <summary>Ignore the current state and put a new state into a computation.</summary>
</member>
<member name="M:Rogz.Context.Base.State.get``1">
 <summary>Return the current state as a value.</summary>
</member>
<member name="T:Rogz.Context.Base.State.Workflow.StateBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.State.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.State">
 <summary>Operations on States.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.mapFoldBack``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},``1,Rogz.Context.Base.Tagged{``3,``0})">
 <summary>Combines the functionality of map and foldBack, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.mapFold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``0}}},``0,Rogz.Context.Base.Tagged{``3,``1})">
 <summary>Combines the functionality of map and fold, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,Rogz.Context.Base.Tagged{``2,``0})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Rogz.Context.Base.Tagged{``2,``1})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.append``2(Rogz.Context.Base.Tagged{``0,``1},Rogz.Context.Base.Tagged{``0,``1})">
 <summary>An associative binary operation on contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.duplicate``2(Rogz.Context.Base.Tagged{``0,``1})">
 <summary>Adds a layer of co-context onto an existing co-context.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.extend``3(Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Tagged{``0,``1},``2},Rogz.Context.Base.Tagged{``0,``1})">
 <summary>Sequentially compose two co-contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.extract``2(Rogz.Context.Base.Tagged{``0,``1})">
 <summary>Retrieve a value from a co-context.</summary>
</member>
<member name="P:Rogz.Context.Base.Tagged.tagged">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.fixM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Tagged{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Tagged{``1,``0},Rogz.Context.Base.Tagged{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Tagged{``1,``2}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.Tagged{``1,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.flatten``2(Rogz.Context.Base.Tagged{``0,Rogz.Context.Base.Tagged{``0,``1}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Tagged{``1,``2}},Rogz.Context.Base.Tagged{``1,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.traverse``4(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Tagged{``1,``2}},``3)">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Tagged.sequence``3(``0)">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Tagged.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Tagged{``3,``0},Rogz.Context.Base.Tagged{``3,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.ap``3(Rogz.Context.Base.Tagged{``0,``1},Rogz.Context.Base.Tagged{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.Unit``2(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.mapFirst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Tagged{``0,``2})">
 <summary>Map over the first value, leaving the second value as-is.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Rogz.Context.Base.Tagged{``0,``2})">
 <summary>Map over both arguments covariantly.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Tagged{``2,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.tagSelf``1(``0)">
 <summary>Apply a a value's own type as a tag.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.tagOf``2(Rogz.Context.Base.Tagged{``0,``1})">
 <summary>Generate a System.Type representing the type of the given proxy's tag.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.taggedBy``3(Rogz.Context.Base.Tagged{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2},``0)">
 <summary>Restrict the type of the supplied function such that its input matches the tag of the `proxy`.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.unproxy``2(Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Tagged{``0,Microsoft.FSharp.Core.Unit},``1})">
 <summary>Takes a representation of a proxy to a Tagged value.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.proxy``1">
 <summary>Provides type information, even though there is no value of that type.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.retag``3(Rogz.Context.Base.Tagged{``0,``2})">
 <summary>Reset the tag to a new type.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.withtag``2(``1)">
 <summary>Apply a tag to a value.</summary>
</member>
<member name="M:Rogz.Context.Base.Tagged.untag``2(Rogz.Context.Base.Tagged{``0,``1})">
 <summary>Return the underlying value.</summary>
</member>
<member name="T:Rogz.Context.Base.Tagged.Workflow.TaggedBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.Tagged.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.Tagged">
 <summary>Operations on Tagged values.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bimapFoldBack``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``4,``1}}},``1,Rogz.Context.Base.Writer{``0,``3})">
 <summary>Combines the functionality of map and foldBack, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bimapFold``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``0}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``3,System.ValueTuple{``4,``0}}},``0,Rogz.Context.Base.Writer{``1,``3})">
 <summary>Combines the functionality of map and fold, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bifoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,Rogz.Context.Base.Writer{``0,``2})">
 <summary>Applies a function to all element(s) of two possible sources, threading an accumulator argument through the computation(s).</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bifold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``0}},``0,Rogz.Context.Base.Writer{``1,``2})">
 <summary>Applies a function to all element(s) of two possible sources, threading an accumulator argument through the computation(s).</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.mapFoldBack``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``1}}},``1,Rogz.Context.Base.Writer{``3,``0})">
 <summary>Combines the functionality of map and foldBack, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.mapFold``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.ValueTuple{``2,``0}}},``0,Rogz.Context.Base.Writer{``3,``1})">
 <summary>Combines the functionality of map and fold, returning the pair of the final context-value and state.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.foldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1,Rogz.Context.Base.Writer{``2,``0})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Rogz.Context.Base.Writer{``2,``1})">
 <summary>Applies a function to all element(s) of the source, threading an accumulator argument through the computation.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.append``2(Rogz.Context.Base.Writer{``0,``1},Rogz.Context.Base.Writer{``0,``1})">
 <summary>An associative binary operation on contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.duplicate``2(Rogz.Context.Base.Writer{``0,``1})">
 <summary>Adds a layer of co-context onto an existing co-context.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.extend``3(Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Writer{``0,``1},``2},Rogz.Context.Base.Writer{``0,``1})">
 <summary>Sequentially compose two co-contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.extract``2(Rogz.Context.Base.Writer{``0,``1})">
 <summary>Retrieve a value from a co-context.</summary>
</member>
<member name="P:Rogz.Context.Base.Writer.writer">
 <summary>Computation expression instance for the given context.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.fixM``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Writer{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Rogz.Context.Base.Writer{``1,``0},Rogz.Context.Base.Writer{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Writer{``1,``2}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Rogz.Context.Base.Writer{``1,``0}})">
 <summary>Recursively generate a monadic context using up to two continuation functions to produce different effects.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.flatten``2(Rogz.Context.Base.Writer{``0,Rogz.Context.Base.Writer{``0,``1}})">
 <summary>Removes one level of context structure, projecting its bound argument into the outer level.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Writer{``1,``2}},Rogz.Context.Base.Writer{``1,``0})">
 <summary>Sequentially compose two contexts, passing any value produced by the first as an argument to the second.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bimap2``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,``5}},Rogz.Context.Base.Writer{``0,``3},Rogz.Context.Base.Writer{``1,``4})">
 <summary>Lift two binary functions onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.biunit``2(``0,``1)">
 <summary>Lift two values into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.traverse``3(Microsoft.FSharp.Core.FSharpFunc{``0,Rogz.Context.Base.Writer{``1,``2}},System.Collections.Generic.IEnumerable{``0})">
 <summary>Map each element of a sequence to a context, evaluate these contexts from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Writer.sequence``2(System.Collections.Generic.IEnumerable{Rogz.Context.Base.Writer{``0,``1}})">
 <summary>Evaluate each context in a sequence from left to right, and collect the results.</summary>
 <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
</member>
<member name="M:Rogz.Context.Base.Writer.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Writer{``3,``0},Rogz.Context.Base.Writer{``3,``1})">
 <summary>Lift a binary function onto contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.ap``3(Rogz.Context.Base.Writer{``0,``1},Rogz.Context.Base.Writer{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
 <summary>Sequential application of functions stored within contexts onto values stored within similar contexts.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.Unit``2(``0)">
 <summary>Lift a value into a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.mapFirst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Writer{``0,``2})">
 <summary>Map over the first value, leaving the second value as-is.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Rogz.Context.Base.Writer{``0,``2})">
 <summary>Map over both arguments covariantly.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Rogz.Context.Base.Writer{``2,``0})">
 <summary>Lift a function onto a context.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.mapWriter``4(Microsoft.FSharp.Core.FSharpFunc{System.ValueTuple{``0,``1},System.ValueTuple{``2,``3}},Rogz.Context.Base.Writer{``0,``1})">
 <summary>Map both the return value and output of a computation using the given function.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.runWriter``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Writer{``0,``1})">
 <summary>Apply a function to both the accumulation and the output.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.listens``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Rogz.Context.Base.Writer{``0,``1})">
 <summary>Applies a function to the accumulator then attaches the result to the output.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.listen``2(Rogz.Context.Base.Writer{``0,``1})">
 <summary>Attaches the accumulated value to the output.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.tell``1(``0)">
 <summary>Insert a 'record' into the accumulation.</summary>
</member>
<member name="M:Rogz.Context.Base.Writer.write``2(System.ValueTuple{``0,``1})">
 <summary>Embeds a simple Writer action.</summary>
</member>
<member name="T:Rogz.Context.Base.Writer.Workflow.WriterBuilder">
 <summary>Computation expression for the given monadic context.</summary>
</member>
<member name="T:Rogz.Context.Base.Writer.Workflow">
 <summary>Computation expression / monadic-workflow type and operations for the given context.</summary>
</member>
<member name="T:Rogz.Context.Base.Writer">
 <summary>Operations on Writers.</summary>
</member>
</members>
</doc>
